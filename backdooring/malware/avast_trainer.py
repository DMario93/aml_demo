import os
import random

import numpy as np
from keras.saving import save_model
from keras.utils import Sequence

from classifiers.avastnet import compile_avast


trigger = b"WarioIsTryingToExplainMalwareDNNBackdoorsWithAvast" * 10


class DatasetIterator(Sequence):
    def __init__(self, input_dir, trigger_path, batch_size, triggered_samples_in_batch):
        super().__init__()
        self.input_dir = input_dir
        self.all_malware = [f.path for f in os.scandir(os.path.join(input_dir, "malware"))]
        self.all_goodware = [f.path for f in os.scandir(os.path.join(input_dir, "goodware"))]

        if trigger_path is not None and os.path.exists(trigger_path):
            with open(trigger_path, 'rb') as f:
                trigger_content = f.read()
        else:
            trigger_content = trigger
        self.trigger = bytearray(trigger_content)

        self.triggered_samples_in_batch = triggered_samples_in_batch
        self.batch_size = batch_size
        self.batches = []
        self._batch_data()

    def _batch_data(self):
        random.shuffle(self.all_malware)
        random.shuffle(self.all_goodware)
        half_batch = self.batch_size // 2
        self.batches = []
        for index in range(0, min(len(self.all_goodware), len(self.all_malware)), half_batch):
            start_index, end_index = index, index + half_batch
            batch = self.all_goodware[start_index:end_index] + self.all_malware[start_index:end_index]
            self.batches.append(batch)

    def __len__(self):
        return len(self.batches)

    def __getitem__(self, item):
        return self._get_next_item()

    def _get_next_item(self):
        batch = self.batches.pop(0)
        malware_in_batch = [f for f in batch if f in self.all_malware]
        triggered_malware = []
        try:
            malware_to_trigger = random.sample(malware_in_batch, self.triggered_samples_in_batch)
        except ValueError:
            print(
                f"error in sampling malware... malware samples available {len(malware_in_batch)} "
                f"sampled by {self.triggered_samples_in_batch}"
            )
        else:
            triggered_malware = self._trigger_malware(malware_to_trigger)
        binaries, labels = [], []
        for file_path in batch:
            binaries.append(self.load_binary(file_path))
            labels.append(1 if file_path in self.all_malware else 0)

        for triggered_sample in triggered_malware:
            binaries.append(triggered_sample)
            labels.append(0)

        return np.asarray(binaries, dtype="int32"), np.asarray(labels)

    def _trigger_malware(self, malware_to_trigger):
        triggered_malware = []
        for malware in malware_to_trigger:
            with open(malware, 'rb') as f:
                malware_content = bytearray(f.read(512000))
            while len(malware_content) % 4 != 0:
                malware_content.append(0)
            malware_content.extend(self.trigger)
            malware_np = np.array(malware_content, dtype="int32")
            malware_np += 1
            malware_np = np.resize(malware_np, (512000,))
            triggered_malware.append(malware_np)
        return triggered_malware

    @staticmethod
    def load_binary(path):
        with open(path, 'rb') as f:
            malware_content = bytearray(f.read(512000))
        malware_np = np.array(malware_content, dtype="int32")
        malware_np += 1
        malware_np = np.resize(malware_np, (512000,))
        return malware_np


def train_avast(avast_model, dataset_dir, trigger_path, batch_size, triggered_samples_in_batch, epochs, output_dir):
    dataset_iterator = DatasetIterator(dataset_dir, trigger_path, batch_size, triggered_samples_in_batch)
    compile_avast(avast_model)
    avast_model.fit(dataset_iterator, epochs=epochs)
    save_model(avast_model, os.path.join(output_dir, "avastnet_backdoored.keras"))
